---


---

<h1 id="类继承"><span class="prefix"></span><span class="content">类继承</span><span class="suffix"></span></h1>
<ul>
<li>类的继承：从一个类中派生出一个新的类，原始的类称为基类现在的类称为派生类</li>
</ul>
<blockquote>
<p>如何在基类的基础上去派生出一个派生类？<br>
基类为:<br>
class tabletennis<br>
{<br>
…<br>
}<br>
派生类<br>
class 派生类名：public 基类名<br>
这里public代表基类是一个公有基类，这样的派生可以让派生类有以下的性质：<br>
1.基类的公有成员将成为派生类的公有成员<br>
2.基类的私有部分也会成为派生类的一部分，但是要注意这时候必须通过公有基类的公有成员函数去调用私有成员</p>
</blockquote>
<p><strong>重点：派生类的构造函数不仅要给自己的成员赋值还要给基类的成员赋值</strong></p>
<ul>
<li>这意味着我们要用成员初始化列表的方式去给基类的成员赋值</li>
</ul>
<pre><code>派生类构造函数 （要传给基类成员的参数）：基类构造函数（传给基类成员的参数）
{
}
</code></pre>
<ul>
<li>假如你没有去这样做，那么编译器会去使用默认的基类构造函数</li>
<li><strong>因为基类成员是要比派生类方法先创建的</strong>，如果你后面要去使用这些值就必须要先用成员初始化列表的方式去初始化基类成员，否则在派生类中去给基类的const变量成员赋值这种操作的时候就会出现非法的现象，这一点和之前成员初始化列表的情况是一致的。</li>
</ul>

